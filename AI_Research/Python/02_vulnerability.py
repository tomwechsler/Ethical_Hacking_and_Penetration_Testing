from openai import OpenAI
from dotenv import load_dotenv
import os
from langchain.agents import Tool
from langchain.utilities import GoogleSearchAPIWrapper
from langchain.agents import initialize_agent
import json

load_dotenv()

client = OpenAI(api_key=os.getenv('API-KEY'))

def search_for_vulnerabilities(dependencies_file_path):
    GOOGLE_CSE_ID = os.getenv('GOOGLE_CSE_ID')
    GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')

    with open(dependencies_file_path, 'r') as file:
        file_contents = file.read()

    search = GoogleSearchAPIWrapper(google_api_key=GOOGLE_API_KEY, google_cse_id=GOOGLE_CSE_ID)
    toolkit = [
    Tool(
        name = "Search",
        func=search.run,
        description="useful for Google searches"
    )]

    agent = initialize_agent(toolkit, client, agent="zero-shot-react-description", verbose=True, return_intermediate_steps=True)

    response = agent({"input": f"""You are a helpful cybersecurity tutor. 
                      Check out this file for dependency management, 
                      and try to search if it references any vulnerable library: ${file_contents} """})
    return response['output']

def read_js_files_from_directory(directory_path):
    js_files_content = []

    for filename in os.listdir(directory_path):
        if filename.endswith('.js'):
            file_path = os.path.join(directory_path, filename)
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
                js_files_content.append(content)
                
    return js_files_content

def analyze_code(code_file_contents):

    prompt = f"""
        You are an excellent software that can spot unsafe coding practices that can introduce 
        security vulnerabilities. 
        You also propose how to fix them before they reach production.
        Do not return markdown format, be as short as possible and return a JSON response. 
        Check this file for any vulnerability: ${code_file_contents} 
    """
    response = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": prompt},
    ],
    temperature=0,
)
    
    return response.choices[0].message.content
        
def main():
    js_files = read_js_files_from_directory("js")
    gpt_report = []
    for js_file in js_files:
        gpt_report.append(analyze_code(js_file))
    
    for gpt_response in gpt_report:
        data = json.loads(gpt_response)
        print(json.dumps(data, indent=2))
    

if __name__ == "__main__":
    main()